// Copyright 2018 FIX94
// This code is licensed to you under the terms of the GNU GPL, version 2;
// see file LICENSE or http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

// Modifications made by Zephiles

#include "loader.h"

#define TO_ARAM 0
#define TO_MRAM 1

// Function/variable addresses
#ifdef SOLA_US
#define GX_FLUSH_ADDRESS             0x802D1A18
#define OS_STOP_AUDIO_SYSTEM_ADDRESS 0x802DC09C
#define OS_DISABLE_SCHEDULER_ADDRESS 0x802DFBA0
#define CARD_GET_RESULT_CODE_ADDRESS 0x802EE914
#define CARD_PROBE_EX_ADDRESS        0x802F0154
#define CARD_MOUNT_ASYNC_ADDRESS     0x802F0818
#define CARD_UNMOUNT_ADDRESS         0x802F0A54
#define CARD_OPEN_ADDRESS            0x802F1758
#define CARD_CLOSE_ADDRESS           0x802F1874
#define CARD_READ_ASYNC_ADDRESS      0x802F1F08
#define CARD_WORK_AREA_ADDRESS       0x8048C9A0
#define GX_FINISHED_ADDRESS          0x805069D0
#elif defined SOLA_EU0
#define GX_FLUSH_ADDRESS             0x802D14BC
#define OS_STOP_AUDIO_SYSTEM_ADDRESS 0x802DBB40
#define OS_DISABLE_SCHEDULER_ADDRESS 0x802DF1C8
#define CARD_GET_RESULT_CODE_ADDRESS 0x802EE298
#define CARD_PROBE_EX_ADDRESS        0x802EFAD8
#define CARD_MOUNT_ASYNC_ADDRESS     0x802F019C
#define CARD_UNMOUNT_ADDRESS         0x802F03D8
#define CARD_OPEN_ADDRESS            0x802F10DC
#define CARD_CLOSE_ADDRESS           0x802F11F8
#define CARD_READ_ASYNC_ADDRESS      0x802F188C
#define CARD_WORK_AREA_ADDRESS       0x8048C2E0
#define GX_FINISHED_ADDRESS          0x80506310
#elif defined SOLA_EU1
#define GX_FLUSH_ADDRESS             0x802D169C
#define OS_STOP_AUDIO_SYSTEM_ADDRESS 0x802DBD20
#define OS_DISABLE_SCHEDULER_ADDRESS 0x802DF3A8
#define CARD_GET_RESULT_CODE_ADDRESS 0x802EE478
#define CARD_PROBE_EX_ADDRESS        0x802EFCB8
#define CARD_MOUNT_ASYNC_ADDRESS     0x802F037C
#define CARD_UNMOUNT_ADDRESS         0x802F05B8
#define CARD_OPEN_ADDRESS            0x802F12BC
#define CARD_CLOSE_ADDRESS           0x802F13D8
#define CARD_READ_ASYNC_ADDRESS      0x802F1A6C
#define CARD_WORK_AREA_ADDRESS       0x8046D800
#define GX_FINISHED_ADDRESS          0x804E7830
#else
#error Error - Invalid region flag.
#endif

typedef unsigned int u32;
typedef unsigned short u16;
typedef unsigned char u8;
typedef volatile unsigned int vu32;
typedef volatile unsigned short vu16;
typedef volatile unsigned char vu8;

typedef struct _cInfo
{
    int chan;
    int fnum;
    int offset;
    int length;
    u16 block;
} cInfo;

static void sync_cache(void *p, u32 n)
{
    u32 start, end;

    start = (u32)p & ~31;
    end = ((u32)p + n + 31) & ~31;
    n = (end - start) >> 5;

    while (n--) {
        asm("dcbst 0,%0 ; icbi 0,%0" : : "b"(p));
        p += 32;
    }
    asm("sync ; isync");
}

static void *_memcpy(void *ptr, const void *src, int size)
{
    char *ptr2 = ptr;
    const char *src2 = src;
    while(size--) *ptr2++ = *src2++;
    return ptr;
}

static void os_enable_interrupts(void)
{
    int msr;
    asm volatile("mfmsr %0 ; ori %0, %0, 0x8000 ; mtmsr %0" : "=r"(msr));
}

static void os_disable_interrupts(void)
{
    int msr;
    asm volatile("mfmsr %0 ; rlwinm %0,%0,0,17,15 ; mtmsr %0" : "=r"(msr));
}

static void ar_dma(u32 type, u32 mram, u32 aram, u32 len)
{
    // Interrupts are enabled so play it safe
    os_disable_interrupts();
    while(*(vu16*)0xCC00500A & 0x200) ;
    *(vu16*)0xCC005020 = (mram>>16);
    *(vu16*)0xCC005022 = (mram&0xFFFF);
    *(vu16*)0xCC005024 = (aram>>16);
    *(vu16*)0xCC005026 = (aram&0xFFFF);
    *(vu16*)0xCC005028 = (type<<15)|(len>>16);
    *(vu16*)0xCC00502A = (len&0xFFFF);
    while(*(vu16*)0xCC00500A & 0x200) ;
    os_enable_interrupts();
}

static int finish_async_func(int ret)
{
    int (*card_get_result_code)(int chan);
    card_get_result_code = (void*)CARD_GET_RESULT_CODE_ADDRESS;
    
    if (ret != 0)
        return ret;
    
    while ((ret = card_get_result_code(0)) == -1);
    return ret;
}

static int card_mount(int chan, void *workArea, void *detachCallback)
{
    int (*card_mount_async)(int chan, void *workArea, void *detachCallback, void *attachCallback);
    card_mount_async = (void*)CARD_MOUNT_ASYNC_ADDRESS;
    
    int ret = card_mount_async(chan, workArea, detachCallback, (void*)0);
    return finish_async_func(ret);
}

static int card_read(cInfo *inf, void *addr, int length, int offset)
{
    int (*card_read_async)(cInfo *inf, void *addr, int length, int offset, void *callback);
    card_read_async = (void*)CARD_READ_ASYNC_ADDRESS;
    
    int ret = card_read_async(inf, addr, length, offset, (void*)0);
    return finish_async_func(ret);
}

static void gx_set_draw_done(void)
{
    // Interrupts should be disabled when this function is called
    
    void (*gx_flush)(void);
    gx_flush = (void*)GX_FLUSH_ADDRESS;
    
    // GX_LOAD_BP_REG(0x45000002);
    *(vu8*)0xCC008000 = 97;
    *(vu32*)0xCC008000 = 0x45000002;
    
    gx_flush();
    
    // _gxfinished = 0;
    *(u8*)GX_FINISHED_ADDRESS = 0;
}

void __attribute__ ((noreturn)) _main(u32 abs_start)
{
    void (*os_stop_audio_system)(void);
    void (*os_disable_scheduler)(void);
    int (*card_probe_ex)(int chan, int *memSize, int *sectorSize);
    int (*card_unmount)(int chan);
    int (*card_open)(int chan, const char *path, cInfo *inf);
    int (*card_close)(cInfo *inf);
    
    os_stop_audio_system = (void*)OS_STOP_AUDIO_SYSTEM_ADDRESS;
    os_disable_scheduler = (void*)OS_DISABLE_SCHEDULER_ADDRESS;
    card_probe_ex = (void*)CARD_PROBE_EX_ADDRESS;
    card_unmount = (void*)CARD_UNMOUNT_ADDRESS;
    card_open = (void*)CARD_OPEN_ADDRESS;
    card_close = (void*)CARD_CLOSE_ADDRESS;
    
    // Disable scheduler for safety
    os_disable_scheduler();
    
    // Prevent BEEPing
    os_stop_audio_system();
    
    // Cleanup GX
    gx_set_draw_done();
    
    // Game id DOLX00 for boot.dol
    *(vu32*)0x80000000 = 0x444F4C58;
    *(vu16*)0x80000004 = 0x3030;
    sync_cache((void*)0x80000000, 6);
    
    // Enable interrupts for CARD access
    os_enable_interrupts();
    
    // Probe for the memory card
    // To prevent an infinite loop, run a maximum of 1,000,000 times
    int ret;
    for (u32 i = 0; i < 1000000; i++)
    {
        ret = card_probe_ex(0, (void*)0, (void*)0);
        if (ret != -1)
            break;
    }
    if (ret != 0)
        for (;;);
    
    // Mount the memory card
    ret = card_mount(0, (void*)CARD_WORK_AREA_ADDRESS, (void*)0);
    if (ret != 0)
        for (;;);
    
    // Open up boot.dol from memory card
    u32 boot_str[3];
    boot_str[0] = 0x626F6F74;
    boot_str[1] = 0x2E646F6C;
    boot_str[2] = 0;
    
    cInfo mInf;
    ret = card_open(0, ((char*)&boot_str), &mInf);
    if (ret != 0)
    {
        card_unmount(0);
        for (;;);
    }
    
    // Copy until it returns error
    u32 curOffset = 0;
    while (card_read(&mInf, (void*)0x80001800, 0x200, curOffset) == 0)
    {
        sync_cache((void*)0x80001800, 0x200);
        ar_dma(TO_ARAM, 0x1800, curOffset, 0x200);
        curOffset += 0x200;
    }
    
    // We are done
    card_close(&mInf);
    card_unmount(0);
    
    // Interrupts not needed anymore
    os_disable_interrupts();
    
    // Copy our loader into mem
    void *loader_abs = (void*)(((u32)loader) + abs_start);
    _memcpy((void*)0x80001800, loader_abs, loader_size);
    sync_cache((void*)0x80001800, loader_size);
    
    // Jump to it
    __asm__ volatile(
        "lis 3, 0x8000\n"
        "ori 3, 3, 0x1800\n"
        "mtlr 3\n"
        "blr\n"
    );
    
    __builtin_unreachable();
}